[{"title":"HashMap","path":"/2024/02/15/HashMap/","content":"基于哈希表实现了Map接口。非线程安全。拉链法。数组+链表（长于64会转化为红黑树以减少搜索时间） 构造方法： 1HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); put方法： 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; get方法: 12345678910public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;// 判断是否包含某个键boolean containsKey = hashMap.containsKey(&quot;banana&quot;); // true// 判断是否包含某个值boolean containsValue = hashMap.containsValue(3); // true 输出跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 12345678910111213141516171819System.out.println(map);//直接输出Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+&quot; &quot;); &#125;//获得键集Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+&quot; &quot;); &#125;//获得值集Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue()); &#125;//获得键值对集map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot; is &quot; + value + &quot; years old&quot;);&#125;);//获得键值对集 迭代器遍历：HashMap 提供了 3 个迭代器： EntryIterator： 键值对迭代器 KeyIterator： 键迭代器 ValueIterator： 值迭代器 基于这 3 个迭代器，HashMap 的遍历方式就分为 3 种： 12345678910111213141516171819202122232425262728293031// 1. 直接遍历节点Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Entry&lt;String, Integer&gt; next = iterator.next();&#125;// 2. 遍历 Key，再通过 Key 查询 Value（性能最差，多一次查询）Iterator&lt;String&gt; keyIterator = map.keySet().iterator();while (keyIterator.hasNext()) &#123; String key = keyIterator.next();&#125;// 3. 直接遍历 ValueIterator&lt;Integer&gt; valueIterator = map.values().iterator();while (valueIterator.hasNext()) &#123; Integer value = valueIterator.next();&#125;Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = map.entrySet();for(Map.Entry&lt;Integer, Integer&gt; entry : entrySet)&#123; System.out.print(entry.getKey()); System.out.println(entry.getValue());&#125;//增强for循环Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = entrySet.iterator();while (iterator.hasNext()) &#123; // 遍历时，需先获取entry，再分别获取key、value Map.Entry entry = iterator.next(); System.out.print(entry.getKey()); System.out.println(entry.getValue());&#125;//通过entrySet获取迭代器","categories":["Java"]},{"title":"1.两数之和","path":"/2024/02/14/1-两数之和/","content":"1.两数之和 暴力枚举最容易想到的解法为双层循环遍历，求出每一种可能。时间复杂度为O(n^2),代码如下 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int []n=new int [2]; for(int i=0;i&lt;nums.length;i++) for(int j=i+1;j&lt;nums.length;j++) if(nums[i]+nums[j]==target)&#123; n[0]=i; n[1]=j; return n; &#125; return null; &#125;&#125; 查找表法为了降低时间复杂度，牺牲一定的空间来记录一些信息以节省一层循环。需要一个集合（查找表）来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。查找表有两种常用的实现： 哈希表（无序） 平衡BST（有序）这里不需要维护元素顺序，选用哈希的思想。（判断某个元素是否存在时，考虑哈希）先看代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; ht = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (ht.containsKey(target - nums[i])) &#123; return new int[]&#123;ht.get(target - nums[i]), i&#125;; &#125; ht.put(nums[i], i); &#125; return null; &#125;&#125; 只需遍历一遍数组，时间复杂度为O（n）不仅要知道元素有没有遍历过，还要知道这个元素对应的下标。遍历数组时，若暂未发现满足条件的匹配值，就将该元素的值和下标的键值对放入哈希表中。元素为key，下标为value。查找需要的元素是否存在于哈希表中。 总结为什么会想到用哈希表？：哈希表能够在常数时间内实现查找操作。通过将数组中的元素存储到哈希表中，然后在遍历的同时检查目标值减去当前元素的差是否在哈希表中存在只需线性复杂度。哈希表为什么用map，map中的key和value用来存什么的？：需要返回的值为下标，需要依据元素值来查找下标。","categories":["力扣刷题"]},{"title":"Markdown简要教程","path":"/2024/02/14/Markdown简要教程/","content":"标题：一个#代表一级，一到六级如下 h1h2h3h4h5h6高亮显示&gt; 高亮 插入链接和图片[显示的文字](url)![图片](url) 列表：无序列表：*或、+加空格如 z x z x有序：数字加小数点加空格1. a b如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格。记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。斜体 用*包围加粗 用**包围代码块用`包围使用反斜杠\\插入语法中用到的特殊符号：\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","categories":["Markdown"]},{"title":"Hello World","path":"/2024/02/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]