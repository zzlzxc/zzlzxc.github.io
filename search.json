[{"title":"Java 垃圾回收机制","path":"/2024/02/20/Java-垃圾回收机制/","content":"垃圾回收当堆内存中，对象或数组产生的地址，通过任何方式都不能被找到后，就会判定为内存中的垃圾，会被Java垃圾回收器在空闲时自动回收清理。","categories":["Java"]},{"title":"Java 数组","path":"/2024/02/20/Java 数组/","content":"数组一种存储同种数据类型的多个值的容器。数组类型的变量记录的是地址值 定义格式int [] t&#x3D;new int[长度];&#x2F;&#x2F;动态初始化int [] t&#x3D;new int[]{1,2,3};&#x2F;&#x2F;静态初始化int [] t&#x3D;{1,2,3}; 索引和访问 索引越界 空指针异常长度：a.length； 二维数组存储一维数组容器的容器 定义格式123456789int [][]a=new int[m][n];int []arr1=&#123;1,2,3&#125;;int []arr2=&#123;1,2,3,4&#125;;int [][]arr=new int[3][3];arr[0]=arr1;arr[1]=arr2;//通过提前初始化一位数组再放入二维数组中就可以访问索引[2][3]int [][]a=new int[][]&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;int [][]arr=&#123;&#123;&#125;,&#123;&#125;&#125;;","categories":["Java"]},{"title":"Java 随机数","path":"/2024/02/19/Java-Random/","content":"伪随机数是看似随机实质是固定的周期性序列,也就是有规则的随机。Java中常见生成随机数方式通常会采用以下几类：Math.random()、Random、ThreadLocalRandom、SecureRandom RandomRandom是Java中用于生成伪随机数的类，它可以帮助我们生成随机数. 12345678import java.util.RandomRandom random = new Random(); int a = random.nextInt(5);//随机生成0~4中间的数字 /*nextBoolean(): 返回随机的boolean值。nextDouble(): 返回随机的double值。nextFloat(): 返回随机的float值。nextInt(): 返回随机的int值。nextLong(): 返回随机的long值。*/ Random是有构造函数的，他的参数可以传一个long类型的值作为种子。Random类的种子决定了随机数生成序列。拥有相同种子的Random实例将生成相同的随机数序列。如果不指定种子，Random类会使用系统当前时间作默认种子，因此每次运行程序生成的随机数序列都不同。 ThreadLocalRandomThreadLocalRandom是Java中用于生成伪随机数的类，它是java.util.concurrent包下的一个工具类，相比于普通的Random类，ThreadLocalRandom具有更好性能表现和更高的并发性。每个线程都有自己的随机数生成器实例，避免了多线程下的竞争和同步开销。 SecureRandom在需要频繁生成随机数，或者安全要求较高的时候，不要使用Random，Random生成的值其实是可以预测的。java.security.SecureRandom类是Java中专门用于生成安全随机数的类，它提供了一种更加安全的随机数生成方式，适用于生成密密钥、随机验证码等需要高安全性的场景。从原理来看，SecureRandom内部使用了RNG (Random Number Generator，随机数生成)算法，来生成一个不可预测的安全随机数。但在JDK的底层，实际上SecureRandom也有多种不同的具体实现。有的是使用安全随机种子加上伪随机数算法来生成安全的随机数，有的是使用真正的随机数生成器来生成随机数。实际使用时，我们可以优先获取高强度的安全随机数生成器；如果没有提供，再使用普通等级的安全随机数生成器。但不管哪种情况，我们都无法指定种子。因为这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”，所以这个种子理论上是不可能会重复的。这也就保证了SecureRandom的安全性，所以最终生成的随机数就是安全的真随机数。SecureRandom 给我们提供了 nextBoolean()、nextBytes()、nextDouble()、nextFloat()、nextInt() 等随机数生成方法generateSeed(int numBytes):参数：numBytes - 需要生成的字节数。返回类型：byte[]。作用：生成指定长度的安全种子。 Math.random()默认生成0~1之间的小数","categories":["Java"]},{"title":"Java IDEA","path":"/2024/02/19/Java-IDEA/","content":"项目结构项目-模块-包-类 常用快捷键psvm：main方法sout：输出语句alt+1：打开&#x2F;隐藏工程目录alt+4：打开&#x2F;隐藏控制台ctrl+alt+l：格式化代码Alt+enter：代码修正提示ctrl+D：向下复制一行ctrl+X：剪切当前一行ctrl+&#x2F;：批量单行注释ctrl+shift+&#x2F;：批量多行注释ctrl+shift+上：向上移动一行ctrl+shift+下：向下移动一行ctrl+alt+v：快速生成接收方法返回值的变量 Debug加&#x2F;删断点：单击左键F7：向下执行1行","categories":["Java"]},{"title":"283.移动零","path":"/2024/02/17/283-移动零/","content":"283.移动零 第一想法：左右双指针代码如下： 123456789101112131415161718class Solution &#123; public void moveZeroes(int[] nums) &#123; int l=0; int r=nums.length-1; while(nums[r]==0&amp;&amp;r&gt;0)&#123;r--;&#125; while(l&lt;r)&#123; if(nums[l]==0)&#123; for(int i=l;i&lt;r;i++)&#123; nums[i]=nums[i+1]; &#125; nums[r]=0; r--; &#125; else l++; &#125; &#125;&#125; 左指针为0，右指针为最靠右的不为零的数。处理左右指针之间的数，若左指针指向元素为0，数组整体左移一位，右指针置零并左移。否则左指针右移。 更好：滑动窗口数组整体左移很耗费时间。代码： 1234567891011121314class Solution &#123; public void moveZeroes(int[] nums) &#123; int n = nums.length, left = 0, right = 0; while (right &lt; n) &#123; if (nums[right] != 0) &#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; &#125; right++; &#125; &#125;&#125; 把左右指针的初值都设为0；右指针 right 用于遍历数组，当右指针指向的元素不为0时，将其与左指针 left 指向的元素交换位置，并且左指针右移。遍历完成后，所有非零元素都已经移动到左边，右边的元素都为0。因为该算法只需要对数组进行一次线性遍历，所以时间复杂度是线性的。即在左右指针之间的元素只有可能是零元素。","categories":["力扣刷题"]},{"title":"Java Object","path":"/2024/02/17/Java-Object/","content":"Object类是Java中所有类的根类（即所有类都直接或间接地继承自Object类），它包含了一些常用的方法和功能，是Java面向对象编程的基础。 方法Object类中的方法一般是被设计为被子类重写的，以便根据具体的需求来实现适合子类的功能 123456789101112131415161718192021public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()//默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; equals在Object类中equals()方法的默认实现是&#x3D;&#x3D;运算比较两个对象的引用是否相等，即判断两对象是否是同一个对象。在Java中如String、Integer这些类都对equals()方法进行了重写，使其用于比较对象内容是否相等。一般情况下，如果我们希望比较两对象的内容是否相等（而不是比较引用是否相等），应该重写该方法，根对象的具体属性判断是否相等。 equals() 与 &#x3D;&#x3D;对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 hashCodehashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 cloneclone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。浅拷贝:拷贝对象和原始对象的引用类型引用同一个对象。可以通过实现Cloneable接口和重写clone()方法来实现浅拷贝。深拷贝:拷贝对象和原始对象的引用类型引用不同对象。实现深拷贝方式一般是序列化和反序列化对象来实现。拷贝工厂：一种允许我们创建对象的副本，同时隐藏复制的具体实现细节，提供一种灵活和可扩展的复制对象方式的设计模式。简例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 接口定义了拷贝方法interface Copyable &#123; Copyable copy();&#125;// 具体类实现了Copyable接口，并实现了copy方法class Person implements Copyable &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public Person(Person person) &#123; this.name = person.getName(); &#125; public String getName() &#123; return name; &#125; public Copyable copy &#123; return new Person(this); &#125; @Override public String toString() &#123; return &quot;Person: &quot; + name &#125;&#125;// 拷贝工厂类负责实例化新对象class CopyFactory &#123; public static Copyable createCopy(Copyable prototype) &#123; return prototype.copy(); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Person person1 = new Person(&quot;Alice &quot;); Person person2 = (Person) CopyFactory.createCopy(person1); System.out.println(person1); System.out.println(person2); &#125;&#125;","categories":["Java"]},{"title":"Java 控制程序流程","path":"/2024/02/17/Java-控制程序流程/","content":"运算符算数：+，-，*，&#x2F;，%（整数相除只能获得整数）（变量）自增自减：++;-- 如果放在变量的后面，先将该变量原本的值取出来参与操作再进行自增自减；放在前面反之赋值是用等号运算符（&#x3D;）进行的。+&#x3D;;-&#x3D;,*&#x3D;,%&#x3D; 符号两边数据先运算再把结果赋给左边。扩展赋值运算符底层自带强制类型转换功能。如： 12short s=1;s +=1;//等效于 s=(short)(s+1); 关系：&#x3D;&#x3D;，!&#x3D;，&gt;,&lt;,&lt;&#x3D;,&gt;&#x3D;逻辑：&amp;,|,!,^ 链接布尔类型&#x2F;关系表达式短路逻辑：&amp;&amp;(符号左边为false时，右边就不执行了。&amp;则左右均要执行),||(如果左边为真，右边不执行) 1234int x=3;int y=4;System.out.println(++4&amp;y--&lt;5);System.out.println(x+&quot;,&quot;+y);//4,3//若为&amp;&amp;，结果为4，4 三元运算符：布尔表达式 ? 值 0:值 1若“布尔表达式”的结果为true，就计算“值0”，而且它的结果成为最终由运算符产生的值。但若“布尔 表达式”的结果为false，计算的就是“值 1”，而且它的结果成为最终由运算符产生的值 几乎所有运算符都只能操作主类型。唯一的例外是“&#x3D;”、“&#x3D;&#x3D;”和“!&#x3D;”，它们能操作所有对象。对一个对象进行操作时，我们真正操作的是它的引用（句柄）。所以倘若“从一个对象到另一个对象”赋值，实际就是将引用从一个地方复制到另一个地方。这意味着假若为 对象使用“C&#x3D;D”，那么C和D最终都会指向最初只有D才指向的那个对象。位运算符：&amp;，|，^,~(包括符号位)&lt;&lt;（向左移动几位就是乘2的几次幂）;&gt;&gt;（向右移动几位就是除以2的几次幂）;&gt;&gt;&gt;; 1234//用亦或实现数据交换a=a^b;b=a^b;a=a^b; 方法、自变量和返回值Java 的“方法”决定了一个对象能够接收的消息，是一段具有独立功能的代码块。方法的基本组成部分包括名字、自变量、返回类型以及主体。Java 的方法只能作为类的一部分创建。自变量列表规定了我们传送给方法的是什么信息。除基本数据类型外，传递的是对象的句柄。方法没有被调用时在方法区的class文件中，被调用时压入栈内存。形参：方法定义中的参数。实参：方法调用中的参数。 执行控制分支循环跳转控制： continue；break；一层 123456标号名:while(true)&#123;\tswitch(表达式)&#123; case 1: break 标号名;\t&#125;&#125; 参数传递基本类型：传递了具体数值引用类型：传递了地址值Java 的参数是以值传递的形式传入方法中，而不是引用传递。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。主方法和传入方法的参数指向的是同一对象。如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。在方法中改变指针引用的对象，那么这两个指针此时指向的就是完全不同的对象，此时一方改变其所指向对象的内容对另一方没有影响。","categories":["Java"]},{"title":"Java 其他部分基础知识点","path":"/2024/02/17/Java-其他部分基础知识点/","content":"Java 背景介绍 Java SE：桌面应用开发 Java ME： Java EE：Web方向的网站开发（数据展示）网站&#x3D;网页+后台服务器 Java的跨平台原理：在不同的操作系统中，都安装一个与操作系统对应的Java虚拟机（JVM） JRE：Java运行环境，包含JVM虚拟机和Java核心类库JDK：Java的软件开发工具包，内部包含了代码的编译工具和运行工具JDK包含JRE和开发工具 DOS 命令dir：显示目录cd：cd..D： ：盘符切换clsjavac xx.java:编译java 类名：运行 变量就是内存中的存储空间，存储着经常发生变化的量作用域：所在的大括号 static关键字通常，我们创建类时会指出那个类的对象的外观与行为。除非用new创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了new 后，才会正式生成数据存储空间，并可使用相应的方法。 当只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象或者是当我们需要一个特殊的方法，它没有与这个类的任何对象关联，也就是说，即使没有创建对象，也需要一个能调用的方法时，可使用 static（静态）关键字。一旦将什么东西设为static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个 static方法，或访问一些 static数据。对于非 static数据和方法，我们必须创建一个对象，并用那个对象访问数据或方法。 main方法public static void main(String[] args){} 标识符命名小驼峰命名：方法，变量大驼峰命名：类 内存分配 栈内存：方法运行时，局部变量存放的位置。引用类型存放的是指向堆内存的地址值。 堆内存：对象。存放被指向的具体的数据。new 出来的内容，存放数据，都有地址值（产生），地址值赋给引用类型的局部变量。 方法区：.class文件加载时进入的内存 本地方法栈： 寄存器： 内存分配默认值：整数：0；浮点数：0.0；布尔：false；字符：空字符；引用：null； 抽象类与接口抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。接口是抽象类的延伸，它可以看成是一个完全抽象的类。接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。接口的字段默认都是 static 和 final 的。 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 使用接口:需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；需要使用多重继承。使用抽象类:需要在几个相关的类中共享代码。需要能控制继承来的成员的访问权限，而不是都为 public。需要继承非静态和非常量字段。 重写与重载**重写(Override)**存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。为了满足里式替换原则，重写有以下两个限制:子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。**重载(Overload)**存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。重载与返回值类型无关。 final关键字 数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。对于基本类型，final 使数值不变；对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 方法声明方法不能被子类重写。private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 类。声明类不允许被继承。 进制java默认10进制，输出也会自动转化为十进制二进制：0b开头八进制：0开头十六进制：0x开头","categories":["Java"]},{"title":"Java 字符串","path":"/2024/02/17/Java-字符串/","content":"StringString是java.lang里的一个类，属于引用类型。String 被声明为 final，因此它不可被继承；内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组；并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。即，这种不可变主要是通过final修饰String类，private final char[]字段对数据的存储，且没有提供任何可以修改char[]字段的方法来实现的。 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。String 经常作为参数，String 不可变性可以保证参数不可变。String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 创建12345678910String s1 = &quot;Runoob&quot;; // String 直接创建String s2 = &quot;Runoob&quot;; // String 直接创建System.out.println(s1==s2); // 相同引用String s4 = new String(&quot;Runoob&quot;); // String 对象创建String s5 = new String(&quot;Runoob&quot;); // String 对象创建//不同引用String s6 = &quot;Runoob&quot;; // String 直接创建String s7 = &quot;Run&quot;+&quot;o&quot;+&quot;ob&quot;; // String 直接创建System.out.println(s6==s7); // 相同引用.Java存在常量优化机制，在编译时会自动创建StringBuilder对象将s7自动拼接为.. String 创建的字符串存储在公共的字符串常量池（堆内存）中，之后用直接创建的方式创建相同序列的字符串会直接复用。而 new 会在堆上新创建字符串对象： 12345 char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;; String helloString = new String(helloArray); //String(char[] value, int offset, int count)：使用字符数组的指定部分创建字符串。//String(StringBuilder sb)：使用StringBuilder对象的内容创建字符串。//String(StringBuffer sb)：使用StringBuffer对象的内容创建字符串。 常用方法length()：获取字符串的长度charAt(int index)：获取指定位置的字符substring(int beginIndex, int endIndex)：获取指定范围内的子字符串(包含头，不包含尾)int indexOf(int ch)返回指定字符在此字符串中第一次出现处的索引。indexOf(String str)：查找指定子字符串在原字符串中第一次出现的位置toUpperCase()、toLowerCase()：字符串转换为大或小写split(String regex)根据指定的正则表达式（传入的字符串）分割字符串，将切割后的内容存入字符串数组中并将其返回 12String info=&quot;张三,22&quot;;String[] sarr=info.split(&quot;,&quot;); string1.concat(string2); 链接字符串，也可使用’+’操作符来连接字符串。但是不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类int compareTo(Object o) 把这个字符串和另一个对象比较。int compareTo(String anotherString) 按字典顺序比较两个字符串。int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。String intern() 返回字符串对象的规范化表示形式。使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。 12345String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();System.out.println(s1.intern() == s3); // true char[] toCharArray() 将此字符串转换为一个新的字符数组。isEmpty() 判断字符串是否为空。equals()比较两字符串内容是否相等。equalsIgnoreCase() 忽略大小写的的比较相等String replace(CharSequence target,CharSequence replacement)将字符串中的某部分内容替换为新的内容 StringBuffer字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer.StringBuffer对象中的字符串内容是可变的，可以通过一系列方法进行修改、插入、删除操作，而不会创建新的对象，这样可以节省内存空间，高效率。StringBuffer是线程安全的，即多个线程可以同时访问同一个StringBuffer对象而不会出现数据混乱的情况。这是因为StringBuffer的方法都是使用synchronized关键字进行同步的。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append(String s)方法始终将这些字符添加到缓冲区的末端；insert(int offset, int i) insert(int offset, String str) 方法则在指定的点添加字符。delete(int start, int end)：删除指定范围内的字符replace(int start, int end, String str)：替换指定范围内的字符reverse()：反转字符串内容indexOf()、lastIndexOf()：查找指定字符或字符串的位置substring(int start, int end)：获取子字符串length()获取字符串长度toString()：将StringBuffer对象转换为String对象void setCharAt(int index, char ch)将给定索引处的字符设置为 ch。void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 StringBuilder提高字符串的操作效率。StringBuilder是java.lang中用于处理可变字符串的类，与StringBuffer类似，但是StringBuilder是非线程安全的。如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer 构造：StringBuilder(String s);sb.append(“1”).append(“1”).append(“1”); 提高效率的原理：使用StringBuilder拼接字符串只会创建一个StringBuilder对象，String每一次进行拼接系统都会自动在堆内存创建一个新的StringBuilder对象","categories":["Java"]},{"title":"125.最长连续序列","path":"/2024/02/17/125-最长连续序列/","content":"125.最长连续序列 最初想法：哈希表先看代码代码思路：首先创建一个HashMap对象m，用于存储数组中的每个元素。遍历数组nums，将其中的每个元素添加到HashMap m中，键为元素值，值为0。再次遍历数组nums，对于每个元素nums[j]，以该元素为起点，进行连续数字的查找。如果HashMap m中包含nums[j]，则表示该数是一个连续序列的起点。然后，以nums[j]为中心，分别向前后查找，并删除HashMap m中相应的记录。在查找和删除的过程中，使用变量x来记录连续序列的长度。当没有相邻的数存在时，更新最长连续序列的长度r。最后返回最长连续序列的长度r。 12345678910111213141516171819202122232425class Solution &#123; public int longestConsecutive(int[] nums) &#123; HashMap &lt;Integer,Integer&gt; m=new HashMap&lt;&gt;(); int x=0; int r=0; for(int i=0;i&lt;nums.length;i++)&#123; m.put(nums[i],0); &#125; for(int j=0;j&lt;nums.length;j++)&#123; if(m.containsKey(nums[j]))&#123; x=1; m.remove(nums[j]); int t1=1; int t2=1; while(true)&#123; if(m.containsKey(nums[j]+t1))&#123;m.remove(nums[j]+t1);x++;t1++;&#125; if(m.containsKey(nums[j]-t2))&#123;m.remove(nums[j]-t2);x++;t2++;&#125; if(!m.containsKey(nums[j]+t1)&amp;&amp;!m.containsKey(nums[j]-t2))break;&#125; if(x&gt;r)r=x; x=0; &#125; &#125; return r; &#125;&#125; 使用哈希表记录数组中每个数字的出现情况，并遍历数组中的每个数，以该数为起点，向前后查找连续的数字并删除哈希表中相应的记录，最后更新最长连续序列的长度。先放入哈希表去掉重复元素，考虑到通过连续元素组成的最长序列中的任意元素求得的长度值是一样的，只需要把原元素按是否连续分组，在求出最长的组长即可。所以遍历数组，过程中跳过已经分好组的元素（即已被从哈希表中删除的元素），对该元素所在的组求组长，去所有结果的最大值。总的时间复杂度为O(n)。 官方题解 1234567891011121314151617181920212223242526class Solution &#123; public int longestConsecutive(int[] nums) &#123; Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums) &#123; num_set.add(num); &#125; int longestStreak = 0; for (int num : num_set) &#123; if (!num_set.contains(num - 1)) &#123; int currentNum = num; int currentStreak = 1; while (num_set.contains(currentNum + 1)) &#123; currentNum += 1; currentStreak += 1; &#125; longestStreak = Math.max(longestStreak, currentStreak); &#125; &#125; return longestStreak; &#125;&#125;/*作者：力扣官方题解链接：https://leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/ 思路大致相同 哈希表记录连续区间长度（动态规划）利用Map减小遍历次数。其value表示的是num所在的连续区间长度。代码思想：遍历nums数组中的所有数字当num是第一次出现时：（1）分别获取到左相邻数字num-1的连续区间长度left和右相邻数字num+1的连续区间长度right；（2）计算得到当前的区间长度为curLen&#x3D;left+right+1curLen&#x3D;left+right+1curLen&#x3D;left+right+1；（3）更新最长区间长度x以及左右边界的区间长度。具体做法是： 首先创建一个HashMap对象map，用于存储每个数字及其所的连续区间长度。 遍历数组nums，对于每个元素num，进行如下操作： 如果map中不包含num，即num第一次出现，执行以下步骤：获取num左边相邻数字的区间长度left，如果不存在则默认为0。获取num右边相邻数字的区间长度right，如果不存在则默认为0。 计算当前连续区间的总长度curLen，即left + right + 1。 更新最长连续序列的长度ans，为当前最大值。 将num加入map中，并设其value为-1，表示已经遍历过该值。 更新当前连续区间的左界(num-left)和右边界(num+right)对应的区间长度为当前区间的总长度curLen。最后返回最长连续序列的长度。 123456789101112131415161718192021222324252627282930class Solution &#123; public int longestConsecutive(int[] nums) &#123; // key表示num，value表示num所在连续区间的长度 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int ans = 0; for (int num : nums) &#123; // 当map中不包含num，也就是num第一次出现 if (!map.containsKey(num)) &#123; // left为num-1所在连续区间的长度，更进一步理解为：左连续区间的长度 int left = map.getOrDefault(num - 1, 0); // right为num+1所在连续区间的长度，更进一步理解为：右连续区间的长度 int right = map.getOrDefault(num + 1, 0); // 当前连续区间的总长度 int curLen = left + right + 1; ans = Math.max(ans, curLen); // 将num加入map中，表示已经遍历过该值。其对应的value可以为任意值。 map.put(num, -1); // 更新当前连续区间左边界和右边界对应的区间长度 map.put(num - left, curLen); map.put(num + right, curLen); &#125; &#125; return ans; &#125;&#125;/*作者：超小白链接：https://leetcode.cn/problems/longest-consecutive-sequence/solutions/1176496/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/ 在代码中的left和right能够分别代表num-1的左连续区间的长度和num+1的右连续区间长度，那么为什么map中的value能够时而表示左区间的长度，时而表示右区间的长度呢？ 关键在于判断条件上：if (!map.containsKey(num))，这行代码表示num之前并未出现过。那么对于key&#x3D;num-1来说，它的value表示的区间就只能是[num-value,num-1]，num-1只能是该区间的左边界值，而其它可能的连续区间都会包含num，不符合上述条件；同理，对于key&#x3D;num+1来说，它的value表示的区间就只能是[num+1,num+value]，num+1只能是该区间的右边界值。 当num已经出现了，这两个区间就可以被联通表示为[num-value1,num+value2]，当前连续区间的左右边界会发生变化，变为num-value1和num+value2，因此我们需要更新这两个边界点对应的区间长度。 整个算法的复杂度为O(n)。 并查集借鉴题解的方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class UnionFind &#123; // 记录每个节点的父节点 private Map&lt;Integer, Integer&gt; parent; // 记录节点所在连通分量的节点个数 private Map&lt;Integer, Integer&gt; count; public UnionFind(int[] nums) &#123; parent = new HashMap&lt;&gt;(); count = new HashMap&lt;&gt;(); // 初始化父节点为自身 for (int num : nums) &#123; parent.put(num, num); count.put(num, 1); &#125; &#125; // 寻找x的父节点，实际上也就是x的最远连续右边界 public Integer find(int x) &#123; if (!parent.containsKey(x)) &#123; return null; &#125; // 遍历找到x的父节点 while (x != parent.get(x)) &#123; // 进行路径压缩 parent.put(x, parent.get(parent.get(x))); x = parent.get(x); &#125; return x; &#125; // 合并两个连通分量，用来将num并入到num+1的连续区间中 // 返回值为x所在连通分量的节点个数 public int union(int x, int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return count.get(rootX); &#125; parent.put(rootX, rootY); // 更新该根结点连通分量的节点个数 count.put(rootY, count.get(rootX) + count.get(rootY)); return count.get(rootY); &#125;&#125;class Solution &#123; public int longestConsecutive(int[] nums) &#123; // 去除nums为空的特例 if (nums == null || nums.length == 0) &#123; return 0; &#125; UnionFind uf = new UnionFind(nums); int ans = 1; // 一次遍历即可 for (int num : nums) &#123; if (uf.find(num + 1) != null) &#123; // union会返回num所在连通分量的节点个数 ans = Math.max(ans, uf.union(num, num + 1)); &#125; &#125; return ans; &#125;&#125;/*作者：超小白链接：https://leetcode.cn/problems/longest-consecutive-sequence/solutions/1176496/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/","tags":["哈希表","动态规划","并查集"],"categories":["力扣刷题"]},{"title":"Java 数据类型","path":"/2024/02/16/Java-数据类型/","content":"数据类型基本数据类型整型量可用十进制、八进制或十六进制形式表示，以1~9开头的数为十进制，以0开头的数为八进制，以0x或0X开头的数为十六进制。byte 8 -128~127short 16 -32768~32767int 32 -65536~65535 （默认）long 64 定义时需在数值后加Lfloat 32 定义时需在数值后加Fdouble 64:浮点型常量在默认情况下是double类型的char 16:一个char表示一个Unicode字符，其值用16位无符号整数表示，范围为0~65535boolean 1 包装类ByeShortIntegerLongFloatDoubleCharacterBoolean基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。自动装箱是指将基数据类型值自动换为对应的包装类型对象。例如，将int的值赋给Integer类型的变量时会自动将int值转换为Integer对象。这样可以方便地将基本数据类型作为参数传递给需要对象类型的方法，或者存储集合类中。自动拆箱是指将包装类型对象自动转换为应的基本数据值。自动装箱和拆箱操作在编译阶段由编译器自动完成，使得代码加简洁易读。然而，在一些特殊情下，可能会发生装箱和拆箱的自动转换带来的性能损耗，因此在性能要求较高的场景中，建议显式地进行装箱和拆箱操作。如 1234567int num = 10;Integer x = 2; // 自动装箱Integer integer = new Integer(num); // 手动装箱Integer integer = Integer.valueOf(num); // 手动装箱Integer integer = 20;int num = integer.intValue(); // 手动拆箱int num = integer; // 自动拆箱 基本数据类型与对象类型最大的不同点在于，基本数据类型是数值，对象类型是基于引用。Java分为堆内存和栈内存，Java对象都在堆内存中存储。基本类型的变量在栈中直接存储的具体数值，对象类型的变量存储的是该对象在堆中地址的引用。 Integer、Byte、Short、LongInteger类包含以下4个常量：MAX_VALUE：是一个常量值，代表基本类型能够表示的最大值；MIN_VALUE：是一个常量值，代表基本类型能够表示的最小值；SIZE：以二进制补码的形式，表示 int值的比特位数；TYPE：代表基本类型 int 的 Class 实例对象。方法：byteValue() 返回byte 转换为byte类型shortValue() 转换为short类型intValue() 转换为int类型toString() 转换为String类型.toBinaryString(num) 将数字转换成二进制字符串.toHexString(num) 将数字转换成八进制.toOctalString(num) 将数字转换成十六进制equals(Object obj)\tboolean\t比较此对象与指定对象是否相等compareTo(Integer another)\t比较两个对象的数值大小，如相等，则返回 0；如调用对象的数值小于 another，则返回负int值；如调用对象的数值大于 another，则返回正int值valueOf(String s) 将String类型的数值转为 Integer对象parseInt(String s) 将String字符串转为 int 数值parseByteparseShort() Float、DoubleMAX_VALUE：表示float的最大值；MIN_VALUE：表示float的最小值；MAX_EXPONENT：float变量可能具有的最大指数；MIN_EXPONENT：float变量可能具有的最小指数；MIN_NORMAL：保存float类型值的最小标准值常量；最小正规范值NaN：保存float类型的非数值常量；表示不是一个数字（Not-a-Number）。SIZE：以二进制补码形式表示的float值的比特位数；TYPE：表示float类型的Class对象实例。POSITIVE_INFINITY：表示正无穷大。NEGATIVE_INFINITY：表示负无穷大。 方法：byteValue() 转为byte类型doubleValue() 转为double类型floatValue() 转为float类型intValue() 强制转换为int类型longValue() 强制转换为long类型shortValue() 强制转换为short类型isNaN() 判断该值是否为非数字值，如果是则返回true，否则返回falseisNaN(float v) 如果指定的参数是一个非数字值，则返回 true，否则返回 falsetoString() 将Float值转为 String对象valueOf(String s) 将String转为Float对象parseFloat(String s) 将String转为float数值parseDouble Charactervoid Character(char value)\t构造一个新的Character对象，表示指定的char值char charValue()\t返回该Character对象的值int compareTo(Character anotherCharacter)\t比较两个Character对象的大小boolean equals(Character anotherCharacter)\t将该对象与指定对象比较，当且仅当参数不是null，且此对象与该Character对象相同时，结果为trueboolean isDigit(char ch)\t判断指定字符是否为数字boolean isLetter(int codePoint)\t判断指定的字符是否为字母boolean isLetterOrDigit(int codePoint)\t判断指定的字符是否为字母或数字boolean isLowerCase(char ch)\t判断指定的字符是否为小写字母boolean isUpperCase(char ch)\t判断指定的字符是否为大写字母char toLowerCase(char ch)\t将指定的字符参数转为小写char toUpperCase(char ch)\t将指定的字符参数转为大写 BooleanTRUE：代表值为true的常量；FALSE：代表值为false的常量；TYPE：表示boolean类型的Class实例对象。booleanValue() 转为boolean类型equals(Object obj)\t判断调用该方法的对象与obj是否相等。当参数不是null，且与调用该方法的对象相同时则返回trueparseBoolean(String s) 将String字符串参数转为 boolean值toString() 返回表示该boolean值的String字符串valueOf(String s) 将指定的字符串转为boolean值 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于:new Integer(123) 每次都会新建一个对象。Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。如： 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true 在Java中，有一种对象缓存机制被称为缓存池（Cache Pool），它用于提高性能和节省内存空间。缓存池是一种存储和重用已经创建的对象的技术，以避免频繁地创建新对象。Boolean、Byte、Character、Short、Integer、Long这些包装类型的对象，以及字符串类型的对象，都有其对应的缓存池。在Java的自动装箱过程中，如果一个值处于缓存池的范围内，那么不会创建新的对象，而是从缓存池中取已经存在的对象。这样可以减少内存占用，提高效率。缓存池的范围以及具体实现方式在不同的Java版本或不同的虚拟机实现中可能会有所不同。valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。可以手动使用valueOf()来确保对象来自缓存池。编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。在 Java 8 中，Integer 缓存池的大小默认为 -128~127。boolean values true and falseall byte valuesshort values between -128 and 127int values between -128 and 127char in the range \\u0000 to \\u007F在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 类型转换隐式类型转换隐式类型转换是指在编译过程中由编译器自动完成的类型转换，它发生在目标类型的范围大于原始的情况下。例如，将一个小范围的整数类型转换为一个大范围的整数类型，或将一个整数类型转换为浮点数类型。取值范围小的数据给数值范围大的数据类型赋值运算时小的会提升为大的类型，再进行运算（byte，short，char会先提升为int） 显式类型转换（强制类型转换）显式类型转换是指通过强制转换运算符（类型名）将一个较大范围的数据类型转换为较小范围的数据类型。在进行显式类型转换时，需要注意目标类型的范围是否可以接受原始类型的值，避免数据精度丢失或溢出的问题。引用类型的强制类型转换主要是指将一个父类类型的引用转换为一个子类类型的引用。这种类型转换被称为向下转型（Downcasting）。当你确信一个对象的实际类型是某个子类，并且你使用这个子的特定方法或属性时，可以使用强制类型转换。在进行强制转换之前，最好先通过使用instanceof运算符来检查要转换的引用是目标类型的实例。只有当引用实际上引用了目标类型的对象时，才能安全地进行强制转换。否则，将会引发CastException异常。 包装类与字符串Byte、Short、Integer、Long、Float、Double这六个类，有一个共同的父类Number。其中，Number提供了一组xxxValue()方法，可以用于将某种类型转换成其他的类型。字符串到其他基本数据类型的转：可以通过包装类（如Integer、Double等）提供的parseXxx()方法将字符串换为对应的基本数据类型。其他类型到字符串的转换：可以使用基本数据类型的toString()方法。 引用数据类型","tags":["Java"],"categories":["Java"]},{"title":"Java 面向对象","path":"/2024/02/16/Java-面向对象/","content":"三大特性封装将数据和行为（基于数据的操作）封装在一起。分离对外接口与内部实现。用户无需知道对象内部的细节，只能通过对象对外提供的接口来访问该对象。其优点为：减少耦合: 可以独立地开发、测试、优化、使用、理解和修改减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能提高软件的可重用性降低风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的 单一职责原则SRP：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。就一个类而言，应该仅有一个引起它变化的原因：不会因为需要修改其他公用的方法而需要修改该类。将不同的变化原因封装在不同的类中，若多个职责总是同时发生改变则封装在同一类中。以避免修改了一个功能而影响到其他的功能。 模块化：模块即为代码片段。模块化是关于如何将软件程序分解为不同模块的思想。衡量标准为高内聚低耦合。使各个模块的变更和复用能在不影响其他模块的情况下进行。 信息隐藏：隐藏模块的实现细节。暴露接口。接口和实现共同体现了模块的职责。 Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private， protected 以及暗示性的friendly。它们决定了谁能使用后续的定义内容。“public”（公共）意味着后续的定义在任何类中均可使用。public也能用来修饰类，在一个java源文件中只能有一个类被声明为public，而且一旦有一个类为public，那这个java源文件的文件名就必须要和这个被public所修饰的类的类名相同，否则编译不能通过。“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。若有人试图访问私有成员，就会得到一个编译器错误。“friendly”（友好的）。即在成员的前面不写任何的访问修饰符的时候，默认就是友好的。所谓友好的，是对同一package的类友好。同一package中的所有类都能访问。被friendly所修饰的成员只能被该类所在同一个package中的子类所继承下来。“protected”（受保护的）。被protected所修饰的成员会被位于同一package中的所有类访问到。同时，被protected所修饰的成员也能被该类的所有子类继承下来。只是一个继承的类可访问受保护的成员，但不能访问私有成员。构造方法：每创建一次对象就会执行一次的方法，用于创建对象和属性初始化标准类： 用private修饰成员变量。用set()方法和get()方法访问私有的类成员变量。 提供无参数构造方法和带多个参数的构造方法 继承“是”的关系。这里需要介绍部分类之间的关系。泛化：即为继承。extends。实现：用来实现一个接口，与继承类似。implements。关联：表明对象之间有联系。在代码实现时，通常将一个类的对象作为另一个类的成员变量。分为单向，双向，自关联，多重关联，组合，聚合等类型。聚合：表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。如车和车轮。代码实现时，在关联的基础上，后者常作为构造方法、set方法或其他方法的参数注入到前者中。组合：和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。代码实现时，在关联的基础上，通常在整体类的构造方法中直接实例化（new）成员类。依赖：一种使用关系。和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有以下的形式:A 类是 B 类中的(某中方法的)局部变量；A 类是 B 类方法当中的一个参数；A 类的方法中调用了B 类的静态方法。A 类向 B 类发送消息，从而影响 B 类发生变化； 里氏替换原则LSP：所有引用基类的地方必须能透明地使用其子类的对象。父类设计为抽象类或接口，子类继承父类，在运行时用子类实例替换父类实例，增加新的功能可以通过增加一个新的子类来实现。在类中注入子类对象即可使用子类所扩展的方法。使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。使用继承时必须要严格遵循LSP。 合成复用原则CRP：优先使用对象组合，而不是通过继承来达到复用的目的。 super访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。 多态多态分为编译时多态和运行时多态:编译时多态主要指方法的重载运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定，如上述编译时使用的是父类的类型，而运行时使用的是子类的类型。 运行时多态有三个条件:继承覆盖(重写)：子类可以重写父类的方法，即子类可以根据自身的需求重写父类的方法实现，从而实现不同的行为。向上转型 面向对象的设计原则最后简单介绍尚未提及的其他面向对象原则： 迪米特法则Lod：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。通俗些说，只与你的直接朋友通信。朋友指：当前对象本身this、以参数形式传入方法中的对象、成员对象、所在集合中的元素、所创建的对象。其思想为多引入中间类以减少耦合。 开闭原则OCP：软件实体应当对扩展开放，对修改关闭追求在不修改原有代码的情况下进行扩展，添加而不是修改。实现方法：抽象 依赖倒转原则DIP：是实现ocp的手段之一。高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应依赖与细节，细节应该依赖于抽象。针对接口&#x2F;抽象层编程。把具体类写在配置文件中。扩展抽象层，修改配置文件。使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明以及数据类型的转换等，而不要用具体类来做这些事情。将具体类的对象通过依赖注入的方式注入到其他对象中。包括构造注入，设值注入和接口注入。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象（具体）来覆盖父类对象（抽象）。 接口隔离原则ISP：客户端不应该依赖那些它不需要的接口。提供尽可能小的接口，而不要提供大的总接口。接口中的方法应该尽量少。否则在不同的实现类中都不得不实现接口中定义的所有方法。 一切都是对象Java 语言假定了我们只希望进行面向对象的程序设计。 用引用指向&#x2F;链接一个对象。 所以对象都必须创建（初始化）。 new 对象的引用存放在堆栈中。对象存放在堆中。 类是对一类具有共同行为和属性的事物的抽象。对象是类的具体化。 成员变量和局部变量的区别： 成员变量：在类中方法外，存储在堆内存。随着对象的存在而存在，消失而消失。有默认的初始化值。 局部变量：在方法内或方法声明上，存储在栈内存。随着方法的调用而存在，调用完毕后消失。没有默认的初始化值，必须先定义赋值才能使用 this在一个方法的内部获得当前对象的句柄。可以调用本类的成员。在get和set方法中避免局部变量和成员变量重名，用this.表示成员变量。","tags":["Java","软件工程"],"categories":["Java","软件工程"]},{"title":"49.字母异位词分组","path":"/2024/02/16/49-字母异位词分组/","content":"49.字母异位词分组 最初的想法先放代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int [] tag=new int[strs.length]; for(int i=0;i&lt;tag.length;i++)&#123; tag[i]=0; &#125; List&lt;List&lt;String&gt;&gt; rr=new ArrayList&lt;List&lt;String&gt;&gt;(); for(int j=0;j&lt;strs.length;j++)&#123; if(tag[j]==0)&#123; HashMap&lt;Character,Integer&gt; m=new HashMap&lt;&gt;(); char[] a=strs[j].toCharArray(); int na=a.length; List &lt;String&gt; e=new ArrayList&lt;&gt;(); e.add(strs[j]); tag[j]=1; for (char c : a) &#123; m.put(c, m.getOrDefault(c, 0) + 1); &#125; int n=m.size(); for(int k=j+1;k&lt;strs.length;k++)&#123; char[] b=strs[k].toCharArray(); if(tag[k]==0&amp;&amp;na==b.length)&#123; HashMap&lt;Character,Integer&gt; m1=new HashMap&lt;&gt;(); for (char c : b) &#123; m1.put(c, m1.getOrDefault(c, 0) + 1); &#125; if(areEqualMaps(m,m1))&#123; e.add(strs[k]); tag[k]=1; &#125; &#125; &#125; rr.add(e); &#125; &#125; return rr; &#125; public boolean areEqualMaps(Map&lt;Character, Integer&gt; map1, Map&lt;Character, Integer&gt; map2) &#123; if (map1.size() != map2.size()) &#123; return false; &#125; for (Map.Entry&lt;Character, Integer&gt; entry : map1.entrySet()) &#123; if (!map2.containsKey(entry.getKey()) || !map2.get(entry.getKey()).equals(entry.getValue())) &#123; return false; &#125; &#125; return true; &#125;&#125; 通过全部测试用例但超出时间限制。主要思想为，先为字符串数组的每个元素做标记，保证大循环只需要遍历一次。在大循环中，用一个HashMap记录该字符串中出现的字符和字符出现的频率。加入一个结果列表。随后遍历剩余未记录进结果的字符串，也用HashMap记录该字符串中出现的字符和字符出现的频率，比较两个HashMap是否相等，若相等，则把字符串加入该结果列表中并记录为已读。时间复杂度为时间复杂度为O(N^2 * M) 改进方法：先排序，再放入哈希表中可以将字符串转换为字符数组，并对字符数组进行排序。这样，如果两个字符串是异位词，它们的排序结果将是相同的。可以利用这一特性来简化问题。 为此，可以把经排序的字符串作为哈希表的键，对应的字母异位词组作为哈希表的值。代码如下 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); String[] ss = new String[strs.length]; List&lt;List&lt;String&gt;&gt; rr = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; strs.length; j++) &#123; char[] chars = strs[j].toCharArray(); Arrays.sort(chars); String sortedStr = String.valueOf(chars); ss[j] = sortedStr; &#125; for (int i = 0; i &lt; strs.length; i++) &#123; List&lt;String&gt; list = map.getOrDefault(ss[i], new ArrayList&lt;&gt;()); list.add(strs[i]); map.put(ss[i], list); &#125; rr.addAll(map.values()); return rr; &#125;&#125; 时间复杂度为nmlogm 改进方法二：计数(官方)由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。官方题解代码： 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; int[] counts = new int[26]; int length = str.length(); for (int i = 0; i &lt; length; i++) &#123; counts[str.charAt(i) - &#x27;a&#x27;]++; &#125; // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 26; i++) &#123; if (counts[i] != 0) &#123; sb.append((char) (&#x27;a&#x27; + i)); sb.append(counts[i]); &#125; &#125; String key = sb.toString(); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 总结关键在于识别出键、值并构建出哈希表","tags":["哈希表"],"categories":["力扣刷题"]},{"title":"Java HashMap","path":"/2024/02/15/Java HashMap/","content":"基于哈希表实现了Map接口。非线程安全。拉链法。数组+链表（长于64会转化为红黑树以减少搜索时间） 构造方法： 1HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); put方法： 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; get方法: 12345678910public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;// 判断是否包含某个键boolean containsKey = hashMap.containsKey(&quot;banana&quot;); // true// 判断是否包含某个值boolean containsValue = hashMap.containsValue(3); // true 输出跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 12345678910111213141516171819System.out.println(map);//直接输出Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+&quot; &quot;); &#125;//获得键集Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+&quot; &quot;); &#125;//获得值集Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue()); &#125;//获得键值对集map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot; is &quot; + value + &quot; years old&quot;);&#125;);//获得键值对集 迭代器遍历：HashMap 提供了 3 个迭代器： EntryIterator： 键值对迭代器 KeyIterator： 键迭代器 ValueIterator： 值迭代器 基于这 3 个迭代器，HashMap 的遍历方式就分为 3 种： 12345678910111213141516171819202122232425262728293031// 1. 直接遍历节点Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Entry&lt;String, Integer&gt; next = iterator.next();&#125;// 2. 遍历 Key，再通过 Key 查询 Value（性能最差，多一次查询）Iterator&lt;String&gt; keyIterator = map.keySet().iterator();while (keyIterator.hasNext()) &#123; String key = keyIterator.next();&#125;// 3. 直接遍历 ValueIterator&lt;Integer&gt; valueIterator = map.values().iterator();while (valueIterator.hasNext()) &#123; Integer value = valueIterator.next();&#125;Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = map.entrySet();for(Map.Entry&lt;Integer, Integer&gt; entry : entrySet)&#123; System.out.print(entry.getKey()); System.out.println(entry.getValue());&#125;//增强for循环Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = entrySet.iterator();while (iterator.hasNext()) &#123; // 遍历时，需先获取entry，再分别获取key、value Map.Entry entry = iterator.next(); System.out.print(entry.getKey()); System.out.println(entry.getValue());&#125;//通过entrySet获取迭代器","tags":["哈希表","Java"],"categories":["Java"]},{"title":"1.两数之和","path":"/2024/02/14/1-两数之和/","content":"1.两数之和 暴力枚举最容易想到的解法为双层循环遍历，求出每一种可能。时间复杂度为O(n^2),代码如下 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int []n=new int [2]; for(int i=0;i&lt;nums.length;i++) for(int j=i+1;j&lt;nums.length;j++) if(nums[i]+nums[j]==target)&#123; n[0]=i; n[1]=j; return n; &#125; return null; &#125;&#125; 查找表法为了降低时间复杂度，牺牲一定的空间来记录一些信息以节省一层循环。需要一个集合（查找表）来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。查找表有两种常用的实现： 哈希表（无序） 平衡BST（有序）这里不需要维护元素顺序，选用哈希的思想。（判断某个元素是否存在时，考虑哈希）先看代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; ht = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (ht.containsKey(target - nums[i])) &#123; return new int[]&#123;ht.get(target - nums[i]), i&#125;; &#125; ht.put(nums[i], i); &#125; return null; &#125;&#125; 只需遍历一遍数组，时间复杂度为O（n）不仅要知道元素有没有遍历过，还要知道这个元素对应的下标。遍历数组时，若暂未发现满足条件的匹配值，就将该元素的值和下标的键值对放入哈希表中。元素为key，下标为value。查找需要的元素是否存在于哈希表中。 总结为什么会想到用哈希表？：哈希表能够在常数时间内实现查找操作。通过将数组中的元素存储到哈希表中，然后在遍历的同时检查目标值减去当前元素的差是否在哈希表中存在只需线性复杂度。哈希表为什么用map，map中的key和value用来存什么的？：需要返回的值为下标，需要依据元素值来查找下标。","tags":["哈希表"],"categories":["力扣刷题"]},{"title":"Markdown简要教程","path":"/2024/02/14/Markdown简要教程/","content":"标题：一个#代表一级，一到六级如下 h1h2h3h4h5h6高亮显示&gt; 高亮 插入链接和图片[显示的文字](url)![图片](url) 列表：无序列表：*或、+加空格如 z x z x有序：数字加小数点加空格1. a b如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格。记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。斜体 用*包围加粗 用**包围代码块用`包围使用反斜杠\\插入语法中用到的特殊符号：\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","categories":["杂项"]}]