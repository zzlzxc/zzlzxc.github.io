[{"title":"Java 数据类型","path":"/2024/02/16/Java-数据类型/","content":"数据类型基本数据类型byte 8 整型量可用十进制、八进制或十六进制形式表示，以19开头的数为十进制，以0开头的数为八进制，以0x或0X开头的数为十六进制。short 16int 32long 64float 32double 64:浮点型常量在默认情况下是double类型的char 16:一个char表示一个Unicode字符，其值用16位无符号整数表示，范围为065535boolean 1 包装类ByeShortIntegerLongFloatDoubleCharacterBoolean基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。自动装箱是指将基数据类型值自动换为对应的包装类型对象。例如，将int的值赋给Integer类型的变量时会自动将int值转换为Integer对象。这样可以方便地将基本数据类型作为参数传递给需要对象类型的方法，或者存储集合类中。自动拆箱是指将包装类型对象自动转换为应的基本数据值。自动装箱和拆箱操作在编译阶段由编译器自动完成，使得代码加简洁易读。然而，在一些特殊情下，可能会发生装箱和拆箱的自动转换带来的性能损耗，因此在性能要求较高的场景中，建议显式地进行装箱和拆箱操作。如 1234567int num = 10;Integer x = 2; // 自动装箱Integer integer = new Integer(num); // 手动装箱Integer integer = Integer.valueOf(num); // 手动装箱Integer integer = 20;int num = integer.intValue(); // 手动拆箱int num = integer; // 自动拆箱 基本数据类型与对象类型最大的不同点在于，基本数据类型是数值，对象类型是基于引用。Java分为堆内存和栈内存，Java对象都在堆内存中存储。基本类型的变量在栈中直接存储的具体数值，对象类型的变量存储的是该对象在堆中地址的引用。 Integer、Byte、Short、LongInteger类包含以下4个常量：MAX_VALUE：是一个常量值，代表基本类型能够表示的最大值；MIN_VALUE：是一个常量值，代表基本类型能够表示的最小值；SIZE：以二进制补码的形式，表示 int值的比特位数；TYPE：代表基本类型 int 的 Class 实例对象。方法：byteValue() 返回byte 转换为byte类型shortValue() 转换为short类型intValue() 转换为int类型toString() 转换为String类型.toBinaryString(num) 将数字转换成二进制字符串.toHexString(num) 将数字转换成八进制.toOctalString(num) 将数字转换成十六进制equals(Object obj)\tboolean\t比较此对象与指定对象是否相等compareTo(Integer another)\t比较两个对象的数值大小，如相等，则返回 0；如调用对象的数值小于 another，则返回负int值；如调用对象的数值大于 another，则返回正int值valueOf(String s) 将String类型的数值转为 Integer对象parseInt(String s) 将String字符串转为 int 数值parseByteparseShort() Float、DoubleMAX_VALUE：表示float的最大值；MIN_VALUE：表示float的最小值；MAX_EXPONENT：float变量可能具有的最大指数；MIN_EXPONENT：float变量可能具有的最小指数；MIN_NORMAL：保存float类型值的最小标准值常量；最小正规范值NaN：保存float类型的非数值常量；表示不是一个数字（Not-a-Number）。SIZE：以二进制补码形式表示的float值的比特位数；TYPE：表示float类型的Class对象实例。POSITIVE_INFINITY：表示正无穷大。NEGATIVE_INFINITY：表示负无穷大。 方法：byteValue() 转为byte类型doubleValue() 转为double类型floatValue() 转为float类型intValue() 强制转换为int类型longValue() 强制转换为long类型shortValue() 强制转换为short类型isNaN() 判断该值是否为非数字值，如果是则返回true，否则返回falseisNaN(float v) 如果指定的参数是一个非数字值，则返回 true，否则返回 falsetoString() 将Float值转为 String对象valueOf(String s) 将String转为Float对象parseFloat(String s) 将String转为float数值parseDouble Charactervoid Character(char value)\t构造一个新的Character对象，表示指定的char值char charValue()\t返回该Character对象的值int compareTo(Character anotherCharacter)\t比较两个Character对象的大小boolean equals(Character anotherCharacter)\t将该对象与指定对象比较，当且仅当参数不是null，且此对象与该Character对象相同时，结果为trueboolean isDigit(char ch)\t判断指定字符是否为数字boolean isLetter(int codePoint)\t判断指定的字符是否为字母boolean isLetterOrDigit(int codePoint)\t判断指定的字符是否为字母或数字boolean isLowerCase(char ch)\t判断指定的字符是否为小写字母boolean isUpperCase(char ch)\t判断指定的字符是否为大写字母char toLowerCase(char ch)\t将指定的字符参数转为小写char toUpperCase(char ch)\t将指定的字符参数转为大写 BooleanTRUE：代表值为true的常量；FALSE：代表值为false的常量；TYPE：表示boolean类型的Class实例对象。booleanValue() 转为boolean类型equals(Object obj)\t判断调用该方法的对象与obj是否相等。当参数不是null，且与调用该方法的对象相同时则返回trueparseBoolean(String s) 将String字符串参数转为 boolean值toString() 返回表示该boolean值的String字符串valueOf(String s) 将指定的字符串转为boolean值 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于:new Integer(123) 每次都会新建一个对象。Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。如： 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true 在Java中，有一种对象缓存机制被称为缓存池（Cache Pool），它用于提高性能和节省内存空间。缓存池是一种存储和重用已经创建的对象的技术，以避免频繁地创建新对象。Boolean、Byte、Character、Short、Integer、Long这些包装类型的对象，以及字符串类型的对象，都有其对应的缓存池。在Java的自动装箱过程中，如果一个值处于缓存池的范围内，那么不会创建新的对象，而是从缓存池中取已经存在的对象。这样可以减少内存占用，提高效率。缓存池的范围以及具体实现方式在不同的Java版本或不同的虚拟机实现中可能会有所不同。valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。可以手动使用valueOf()来确保对象来自缓存池。编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。在 Java 8 中，Integer 缓存池的大小默认为 -128~127。boolean values true and falseall byte valuesshort values between -128 and 127int values between -128 and 127char in the range \\u0000 to \\u007F在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 类型转换隐式类型转换隐式类型转换是指在编译过程中由编译器自动完成的类型转换，它发生在目标类型的范围大于原始的情况下。例如，将一个小范围的整数类型转换为一个大范围的整数类型，或将一个整数类型转换为浮点数类型。 显式类型转换（强制类型转换）显式类型转换是指通过强制转换运算符（类型名）将一个较大范围的数据类型转换为较小范围的数据类型。在进行显式类型转换时，需要注意目标类型的范围是否可以接受原始类型的值，避免数据精度丢失或溢出的问题。引用类型的强制类型转换主要是指将一个父类类型的引用转换为一个子类类型的引用。这种类型转换被称为向下转型（Downcasting）。当你确信一个对象的实际类型是某个子类，并且你使用这个子的特定方法或属性时，可以使用强制类型转换。在进行强制转换之前，最好先通过使用instanceof运算符来检查要转换的引用是目标类型的实例。只有当引用实际上引用了目标类型的对象时，才能安全地进行强制转换。否则，将会引发CastException异常。 包装类与字符串Byte、Short、Integer、Long、Float、Double这六个类，有一个共同的父类Number。其中，Number提供了一组xxxValue()方法，可以用于将某种类型转换成其他的类型。字符串到其他基本数据类型的转：可以通过包装类（如Integer、Double等）提供的parseXxx()方法将字符串换为对应的基本数据类型。其他类型到字符串的转换：可以使用基本数据类型的toString()方法。","categories":["Java"]},{"title":"Java 面向对象","path":"/2024/02/16/Java-面向对象/","content":"三大特性封装将数据和行为（基于数据的操作）封装在一起。分离对外接口与内部实现。用户无需知道对象内部的细节，只能通过对象对外提供的接口来访问该对象。其优点为：减少耦合: 可以独立地开发、测试、优化、使用、理解和修改减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能提高软件的可重用性降低风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的 单一职责原则SRP：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。就一个类而言，应该仅有一个引起它变化的原因：不会因为需要修改其他公用的方法而需要修改该类。将不同的变化原因封装在不同的类中，若多个职责总是同时发生改变则封装在同一类中。以避免修改了一个功能而影响到其他的功能。 模块化：模块即为代码片段。模块化是关于如何将软件程序分解为不同模块的思想。衡量标准为高内聚低耦合。使各个模块的变更和复用能在不影响其他模块的情况下进行。 信息隐藏：隐藏模块的实现细节。暴露接口。接口和实现共同体现了模块的职责。 继承“是”的关系。这里需要介绍部分类之间的关系。泛化：即为继承。extends。实现：用来实现一个接口，与继承类似。implements。关联：表明对象之间有联系。在代码实现时，通常将一个类的对象作为另一个类的成员变量。分为单向，双向，自关联，多重关联，组合，聚合等类型。聚合：表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。如车和车轮。代码实现时，在关联的基础上，后者常作为构造方法、set方法或其他方法的参数注入到前者中。组合：和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。代码实现时，在关联的基础上，通常在整体类的构造方法中直接实例化（new）成员类。依赖：一种使用关系。和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有以下的形式:A 类是 B 类中的(某中方法的)局部变量；A 类是 B 类方法当中的一个参数；A 类的方法中调用了B 类的静态方法。A 类向 B 类发送消息，从而影响 B 类发生变化； 里氏替换原则LSP：所有引用基类的地方必须能透明地使用其子类的对象。父类设计为抽象类或接口，子类继承父类，在运行时用子类实例替换父类实例，增加新的功能可以通过增加一个新的子类来实现。在类中注入子类对象即可使用子类所扩展的方法。使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。使用继承时必须要严格遵循LSP。 合成复用原则CRP：优先使用对象组合，而不是通过继承来达到复用的目的。 多态多态分为编译时多态和运行时多态:编译时多态主要指方法的重载运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定，如上述编译时使用的是父类的类型，而运行时使用的是子类的类型。 运行时多态有三个条件:继承覆盖(重写)：子类可以重写父类的方法，即子类可以根据自身的需求重写父类的方法实现，从而实现不同的行为。向上转型 面向对象的设计原则最后简单介绍尚未提及的其他面向对象原则： 迪米特法则Lod：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。通俗些说，只与你的直接朋友通信。朋友指：当前对象本身this、以参数形式传入方法中的对象、成员对象、所在集合中的元素、所创建的对象。其思想为多引入中间类以减少耦合。 开闭原则OCP：软件实体应当对扩展开放，对修改关闭追求在不修改原有代码的情况下进行扩展，添加而不是修改。实现方法：抽象 依赖倒转原则DIP：是实现ocp的手段之一。高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应依赖与细节，细节应该依赖于抽象。针对接口&#x2F;抽象层编程。把具体类写在配置文件中。扩展抽象层，修改配置文件。使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明以及数据类型的转换等，而不要用具体类来做这些事情。将具体类的对象通过依赖注入的方式注入到其他对象中。包括构造注入，设值注入和接口注入。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象（具体）来覆盖父类对象（抽象）。 接口隔离原则ISP：客户端不应该依赖那些它不需要的接口。提供尽可能小的接口，而不要提供大的总接口。接口中的方法应该尽量少。否则在不同的实现类中都不得不实现接口中定义的所有方法。","tags":["Java"],"categories":["Java"]},{"title":"49.字母异位词分组","path":"/2024/02/16/49-字母异位词分组/","content":"49.字母异位词分组 最初的想法先放代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int [] tag=new int[strs.length]; for(int i=0;i&lt;tag.length;i++)&#123; tag[i]=0; &#125; List&lt;List&lt;String&gt;&gt; rr=new ArrayList&lt;List&lt;String&gt;&gt;(); for(int j=0;j&lt;strs.length;j++)&#123; if(tag[j]==0)&#123; HashMap&lt;Character,Integer&gt; m=new HashMap&lt;&gt;(); char[] a=strs[j].toCharArray(); int na=a.length; List &lt;String&gt; e=new ArrayList&lt;&gt;(); e.add(strs[j]); tag[j]=1; for (char c : a) &#123; m.put(c, m.getOrDefault(c, 0) + 1); &#125; int n=m.size(); for(int k=j+1;k&lt;strs.length;k++)&#123; char[] b=strs[k].toCharArray(); if(tag[k]==0&amp;&amp;na==b.length)&#123; HashMap&lt;Character,Integer&gt; m1=new HashMap&lt;&gt;(); for (char c : b) &#123; m1.put(c, m1.getOrDefault(c, 0) + 1); &#125; if(areEqualMaps(m,m1))&#123; e.add(strs[k]); tag[k]=1; &#125; &#125; &#125; rr.add(e); &#125; &#125; return rr; &#125; public boolean areEqualMaps(Map&lt;Character, Integer&gt; map1, Map&lt;Character, Integer&gt; map2) &#123; if (map1.size() != map2.size()) &#123; return false; &#125; for (Map.Entry&lt;Character, Integer&gt; entry : map1.entrySet()) &#123; if (!map2.containsKey(entry.getKey()) || !map2.get(entry.getKey()).equals(entry.getValue())) &#123; return false; &#125; &#125; return true; &#125;&#125; 通过全部测试用例但超出时间限制。主要思想为，先为字符串数组的每个元素做标记，保证大循环只需要遍历一次。在大循环中，用一个HashMap记录该字符串中出现的字符和字符出现的频率。加入一个结果列表。随后遍历剩余未记录进结果的字符串，也用HashMap记录该字符串中出现的字符和字符出现的频率，比较两个HashMap是否相等，若相等，则把字符串加入该结果列表中并记录为已读。时间复杂度为时间复杂度为O(N^2 * M) 改进方法：先排序，再放入哈希表中可以将字符串转换为字符数组，并对字符数组进行排序。这样，如果两个字符串是异位词，它们的排序结果将是相同的。可以利用这一特性来简化问题。 为此，可以把经排序的字符串作为哈希表的键，对应的字母异位词组作为哈希表的值。代码如下 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); String[] ss = new String[strs.length]; List&lt;List&lt;String&gt;&gt; rr = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; strs.length; j++) &#123; char[] chars = strs[j].toCharArray(); Arrays.sort(chars); String sortedStr = String.valueOf(chars); ss[j] = sortedStr; &#125; for (int i = 0; i &lt; strs.length; i++) &#123; List&lt;String&gt; list = map.getOrDefault(ss[i], new ArrayList&lt;&gt;()); list.add(strs[i]); map.put(ss[i], list); &#125; rr.addAll(map.values()); return rr; &#125;&#125; 时间复杂度为nmlogm 改进方法二：计数(官方)由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。官方题解代码： 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; int[] counts = new int[26]; int length = str.length(); for (int i = 0; i &lt; length; i++) &#123; counts[str.charAt(i) - &#x27;a&#x27;]++; &#125; // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 26; i++) &#123; if (counts[i] != 0) &#123; sb.append((char) (&#x27;a&#x27; + i)); sb.append(counts[i]); &#125; &#125; String key = sb.toString(); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 总结关键在于识别出键、值并构建出哈希表","tags":["哈希表"],"categories":["力扣刷题"]},{"title":"HashMap","path":"/2024/02/15/HashMap/","content":"基于哈希表实现了Map接口。非线程安全。拉链法。数组+链表（长于64会转化为红黑树以减少搜索时间） 构造方法： 1HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); put方法： 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; get方法: 12345678910public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;// 判断是否包含某个键boolean containsKey = hashMap.containsKey(&quot;banana&quot;); // true// 判断是否包含某个值boolean containsValue = hashMap.containsValue(3); // true 输出跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 12345678910111213141516171819System.out.println(map);//直接输出Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+&quot; &quot;); &#125;//获得键集Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+&quot; &quot;); &#125;//获得值集Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue()); &#125;//获得键值对集map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot; is &quot; + value + &quot; years old&quot;);&#125;);//获得键值对集 迭代器遍历：HashMap 提供了 3 个迭代器： EntryIterator： 键值对迭代器 KeyIterator： 键迭代器 ValueIterator： 值迭代器 基于这 3 个迭代器，HashMap 的遍历方式就分为 3 种： 12345678910111213141516171819202122232425262728293031// 1. 直接遍历节点Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Entry&lt;String, Integer&gt; next = iterator.next();&#125;// 2. 遍历 Key，再通过 Key 查询 Value（性能最差，多一次查询）Iterator&lt;String&gt; keyIterator = map.keySet().iterator();while (keyIterator.hasNext()) &#123; String key = keyIterator.next();&#125;// 3. 直接遍历 ValueIterator&lt;Integer&gt; valueIterator = map.values().iterator();while (valueIterator.hasNext()) &#123; Integer value = valueIterator.next();&#125;Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = map.entrySet();for(Map.Entry&lt;Integer, Integer&gt; entry : entrySet)&#123; System.out.print(entry.getKey()); System.out.println(entry.getValue());&#125;//增强for循环Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = entrySet.iterator();while (iterator.hasNext()) &#123; // 遍历时，需先获取entry，再分别获取key、value Map.Entry entry = iterator.next(); System.out.print(entry.getKey()); System.out.println(entry.getValue());&#125;//通过entrySet获取迭代器","tags":["哈希表","Java"],"categories":["Java"]},{"title":"1.两数之和","path":"/2024/02/14/1-两数之和/","content":"1.两数之和 暴力枚举最容易想到的解法为双层循环遍历，求出每一种可能。时间复杂度为O(n^2),代码如下 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int []n=new int [2]; for(int i=0;i&lt;nums.length;i++) for(int j=i+1;j&lt;nums.length;j++) if(nums[i]+nums[j]==target)&#123; n[0]=i; n[1]=j; return n; &#125; return null; &#125;&#125; 查找表法为了降低时间复杂度，牺牲一定的空间来记录一些信息以节省一层循环。需要一个集合（查找表）来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是是否出现在这个集合。查找表有两种常用的实现： 哈希表（无序） 平衡BST（有序）这里不需要维护元素顺序，选用哈希的思想。（判断某个元素是否存在时，考虑哈希）先看代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; ht = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (ht.containsKey(target - nums[i])) &#123; return new int[]&#123;ht.get(target - nums[i]), i&#125;; &#125; ht.put(nums[i], i); &#125; return null; &#125;&#125; 只需遍历一遍数组，时间复杂度为O（n）不仅要知道元素有没有遍历过，还要知道这个元素对应的下标。遍历数组时，若暂未发现满足条件的匹配值，就将该元素的值和下标的键值对放入哈希表中。元素为key，下标为value。查找需要的元素是否存在于哈希表中。 总结为什么会想到用哈希表？：哈希表能够在常数时间内实现查找操作。通过将数组中的元素存储到哈希表中，然后在遍历的同时检查目标值减去当前元素的差是否在哈希表中存在只需线性复杂度。哈希表为什么用map，map中的key和value用来存什么的？：需要返回的值为下标，需要依据元素值来查找下标。","tags":["哈希表"],"categories":["力扣刷题"]},{"title":"Markdown简要教程","path":"/2024/02/14/Markdown简要教程/","content":"标题：一个#代表一级，一到六级如下 h1h2h3h4h5h6高亮显示&gt; 高亮 插入链接和图片[显示的文字](url)![图片](url) 列表：无序列表：*或、+加空格如 z x z x有序：数字加小数点加空格1. a b如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格。记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。斜体 用*包围加粗 用**包围代码块用`包围使用反斜杠\\插入语法中用到的特殊符号：\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","categories":["Markdown"]}]